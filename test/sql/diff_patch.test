# name: test/sql/diff_patch.test
# description: scenario tests for diff_patch extension (UTF-8, + - =)
# group: [sql]

require diff_patch

# Setup a UTF-8 demo table
statement ok
CREATE TEMP TABLE demo AS
  SELECT *
  FROM (VALUES
    (1, 'café', 'ca🌟é!'),
    (2, '你好世界', '你🌈好地球'),
    (3, 'abc', 'abcfoo')
  ) AS t(id, old_content, new_content);

# Inspect demo
query ITT
SELECT id, old_content, new_content FROM demo ORDER BY id
----
1	café	ca🌟é!
2	你好世界	你🌈好地球
3	abc	abcfoo

# Derive columns; fixed field names (_ops, _plus_concat, _vals)
query TTTI
SELECT CAST(id AS VARCHAR), (s)._ops, (s)._plus_concat, list_extract((s)._vals, 1)
FROM (SELECT id, make_cols_from_text(old_content, new_content, 'nc') AS s FROM demo) t
ORDER BY id
----
1	=-+=+	🌟!	2
2	=+=-+	🌈地球	1
3	=+	foo	3

# Reconstruct new_content using apply_cols
query TT
SELECT new_content,
       apply_cols(old_content, (s)._ops, (s)._plus_concat, (s)._vals) AS reconstructed
FROM (SELECT old_content, new_content, make_cols_from_text(old_content, new_content, 'nc') AS s FROM demo) t
ORDER BY new_content
----
abcfoo	abcfoo
ca🌟é!	ca🌟é!
你🌈好地球	你🌈好地球

# diff_patch with make_patch over demo rows
query TT
SELECT new_content,
       diff_patch(old_content, make_patch(old_content, new_content)) AS patched
FROM demo
ORDER BY id
----
ca🌟é!	ca🌟é!
你🌈好地球	你🌈好地球
abcfoo	abcfoo

# Length checks: length(new_content) == cols_len(ops, vals) == patch_len(make_patch(...))
query TTT
SELECT CAST(id AS VARCHAR),
       length(new_content),
       cols_len((s)._ops, (s)._vals)
FROM (SELECT id, new_content, make_cols_from_text(old_content, new_content, 'nc') AS s FROM demo) t
ORDER BY id
----
1	5	5
2	5	5
3	6	6

query TI
SELECT CAST(id AS VARCHAR), patch_len(make_patch(old_content, new_content))
FROM demo
ORDER BY id
----
1	5
2	5
3	6

# ---------------- Edge Cases: UTF-8 / NULL / Empty Patch ----------------

# Empty patch JSON -> empty string; length 0
query IT
SELECT diff_patch('abc', '[]'), patch_len('[]')
----
NULL	0

# make_cols on empty patch: empty fields
query TTT
SELECT (s)._ops, (s)._plus_concat, length((s)._vals)
FROM (SELECT make_cols('[]', 'p') AS s) t
----
(empty)	(empty)	0

# cols_len on empty ops/vals is 0
query I
SELECT cols_len('', LIST_VALUE())
----
0

# diff_patch with negative counts clamps to 0
query I
SELECT diff_patch('abc', '[["=", -2], ["+", "X"]]')
----
X

# make_cols handles numeric '+' payload by stringifying
query II
SELECT (s)._plus_concat, list_extract((s)._vals, 2)
FROM (SELECT make_cols('[["=", 1], ["+", 123]]', 'n') AS s) t
----
123	3

# NULL behavior
# diff_patch: empty patch returns empty string (no change)
query I
SELECT diff_patch('foo', '[]')
----
NULL

# apply_cols: old NULL + empty ops -> (empty); any NULL among ops/plus/vals -> NULL
query TT
SELECT apply_cols(NULL, '', '', LIST_VALUE()), apply_cols('abc', NULL, NULL, NULL)
----
NULL	NULL

# apply_cols: old NULL with '+' should return inserted text
query I
SELECT apply_cols(NULL, '+', 'foo', LIST_VALUE(3))
----
foo

# diff_patch: old NULL with '+' should return inserted text
query I
SELECT diff_patch(NULL, '[["+", "foo"]]')
----
foo

# make_patch: old NULL and new 'foo' -> insertion patch
query I
SELECT make_patch(NULL, 'foo')
----
[["+","foo"]]

# make_cols_from_text: old NULL and new 'foo' -> '+' columns
query I
SELECT make_cols_from_text(NULL, 'foo', 'nc')
----
{'_ops': +, '_plus_concat': foo, '_vals': [3]}

# make_patch: new NULL -> empty patch []
query I
SELECT make_patch('foo', NULL)
----
[]

# make_cols_from_text: new NULL -> empty columns
query I
SELECT make_cols_from_text('foo', NULL, 'nc')
----
{'_ops': '', '_plus_concat': '', '_vals': []}

# make_cols_from_text: new NULL -> empty columns
query TTT
SELECT (s)._ops, (s)._plus_concat, (s)._vals FROM (SELECT make_cols_from_text('foo', NULL, 'nc') AS s)
----
(empty)	(empty)	[]

# make_cols_from_text: new NULL -> empty columns
query I
SELECT apply_cols('foo', (s)._ops, (s)._plus_concat, (s)._vals) FROM (SELECT make_cols_from_text('foo', NULL, 'nc') AS s)
----
NULL
